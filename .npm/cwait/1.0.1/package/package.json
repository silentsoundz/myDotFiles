{"name":"cwait","version":"1.0.1","description":"Limit number of promises running in parallel","main":"dist/cwait.js","typings":"dist/cwait.d.ts","scripts":{"tsc":"tsc","docts":"docts","tslint":"tslint","prepublish":"tslint -c src/tslint.json src/*.ts && tsc -p src","test":"tsc -p test && node test/test.js"},"author":{"name":"Juha JÃ¤rvi"},"license":"MIT","repository":{"type":"git","url":"git+https://github.com/charto/cwait.git"},"bugs":{"url":"https://github.com/charto/cwait/issues"},"homepage":"https://github.com/charto/cwait#readme","devDependencies":{"@types/bluebird":"^3.0.36","bluebird":"^3.4.6","docts":"~0.1.0","tslint":"^4.0.2","typescript":"^2.1.4"},"readme":"cwait\n=====\n\n[![build status](https://travis-ci.org/charto/cwait.svg?branch=master)](http://travis-ci.org/charto/cwait)\n[![npm version](https://img.shields.io/npm/v/cwait.svg)](https://www.npmjs.com/package/cwait)\n\n`cwait` provides a queue handler ([`TaskQueue`](#api-TaskQueue)) and a wrapper ([`Task`](#api-Task)) for promises,\nto limit how many are being resolved simultaneously. It can wrap any ES6-compatible promises.\nThis allows for example limiting simultaneous downloads with minor changes to existing code.\nJust wrap your existing \"download finished\" promise and use it as before.\n\nThis is a tiny library with no dependencies, usable both in browsers and Node.js.\n\nUsage\n-----\n\nCreate a new `TaskQueue` passing it whatever `Promise` constructor you're using (ES6, Bluebird, some other shim...)\nand the maximum number of promise-returning functions to run concurrently.\nThen just call `queue.wrap(<function>)` instead of `<function>` to limit simultaneous execution.\n\nSimple Node.js example:\n\n```TypeScript\nimport * as Promise from 'bluebird';\nimport {TaskQueue} from 'cwait';\n\n/** Queue allowing 3 concurrent function calls. */\nvar queue = new TaskQueue(Promise, 3);\n\nPromise.map(list, download); // Download all listed files simultaneously.\n\nPromise.map(list, queue.wrap(download))); // Download 3 files at a time.\n```\n\nSee [`test/test.ts`](test/test.ts) for some runnable code or run it like this:\n\n```sh\ngit clone https://github.com/charto/cwait.git\ncd cwait\nnpm install\nnpm test\n```\n\nRecursion\n---------\n\nRecursive loops that run in parallel require special care.\nNested concurrency-limited calls (that are not tail-recursive) must be wrapped in `queue.unblock()`.\n\nHere's a simple example that fails:\n\n```JavaScript\nvar queue = new (require('cwait').TaskQueue)(Promise, 3);\n\nvar rec = queue.wrap(function(n) {\n    console.log(n);\n    return(n && Promise.resolve(rec(n - 1)));\n});\n\nrec(10);\n```\n\nIt only prints numbers 10, 9 and 8.\nMore calls don't get scheduled because there are already 3 promises pending.\nFor example Node.js exits immediately afterwards because the program is not blocked waiting for any system calls.\n\nPassing a promise to `queue.unblock(promise)` tells `queue` that\nthe current function will wait for `promise` to resolve before continuing.\nOne additional concurrent function is then allowed until the promise resolves.\n\nBe careful not to call `queue.unblock()` more than once (concurrently) from inside a wrapped function!\nOtherwise the queue may permit more simultaneous tasks than the intended limit.\n\nHere is a corrected example:\n\n```JavaScript\nvar queue = new (require('cwait').TaskQueue)(Promise, 3);\n\nvar rec = queue.wrap(function(n) {\n    console.log(n);\n    return(n && queue.unblock(Promise.resolve(rec(n - 1))));\n});\n\nrec(10);\n```\n\nAdvanced example with recursion\n-------------------------------\n\nThe following code recursively calculates the 10th Fibonacci number (55)\nrunning 3 recursive steps in parallel, each with an artificial 10-millisecond delay.\n\nAt the end, it prints the result (55) and the number of concurrent calls (3).\n\n```JavaScript\nvar queue = new (require('cwait').TaskQueue)(Promise, 3);\n\nvar maxRunning = 0;\nvar running = 0;\nvar delay = 10;\n\nvar fib = queue.wrap(function(n) {\n\t// \"Calculation\" starts. Track maximum concurrent executions.\n    if(++running > maxRunning) maxRunning = running;\n\n    return(new Promise(function(resolve, reject) {\n        setTimeout(function() {\n\t\t\t// \"Calculation\" ends.\n            --running;\n\n\t\t\t// Each Fibonacci number is the sum of the previous two, except\n\t\t\t// the first ones are 0, 1 (starting from the 0th number).\n\t\t\t// Calculate them in parallel and unblock the queue until ready.\n\n            resolve(n < 2 ? n :\n                queue.unblock(Promise.all([\n                    fib(n - 1),\n                    fib(n - 2)\n                ])).then(function(r) {\n\t\t\t\t\t// Sum results from parallel recursion.\n                    return(r[0] + r[1]);\n                })\n            );\n        }, delay);\n    }));\n});\n\nfib(10).then(function(x) {\n    console.log('Result: ' + x);\n    console.log('Concurrency: ' + maxRunning);\n});\n```\n\nAPI\n===\nDocs generated using [`docts`](https://github.com/charto/docts)\n\n\n>\n> <a name=\"api-Task\"></a>\n> ### Class [`Task`](#api-Task)\n> <em>Task wraps a promise, delaying it until some resource gets less busy.</em>  \n> Source code: [`<>`](http://github.com/charto/cwait/blob/bcc3b2b/src/Task.ts#L49-L80)  \n>  \n> Methods:  \n> > **new( )** <sup>&rArr; <code>[Task](#api-Task)&lt;PromiseType&gt;</code></sup> [`<>`](http://github.com/charto/cwait/blob/bcc3b2b/src/Task.ts#L50-L53)  \n> > &emsp;&#x25aa; func <sup><code>() =&gt; PromiseType</code></sup>  \n> > &emsp;&#x25aa; Promise <sup><code>[PromisyClass](#api-PromisyClass)&lt;PromiseType&gt;</code></sup>  \n> > **.delay( )** <sup>&rArr; <code>PromiseType</code></sup> [`<>`](http://github.com/charto/cwait/blob/bcc3b2b/src/Task.ts#L57-L66)  \n> > &emsp;<em>Wrap task result in a new promise so it can be resolved later.</em>  \n> > **.resume( )** <sup>&rArr; <code>PromiseType</code></sup> [`<>`](http://github.com/charto/cwait/blob/bcc3b2b/src/Task.ts#L70-L72)  \n> > &emsp;<em>Start the task and call onFinish when done.</em>  \n> > &emsp;&#x25aa; onFinish <sup><code>() =&gt; void</code></sup>  \n>\n> <a name=\"api-TaskQueue\"></a>\n> ### Class [`TaskQueue`](#api-TaskQueue)\n> Source code: [`<>`](http://github.com/charto/cwait/blob/c57c0fd/src/TaskQueue.ts#L6-L75)  \n>  \n> Methods:  \n> > **new( )** <sup>&rArr; <code>[TaskQueue](#api-TaskQueue)&lt;PromiseType&gt;</code></sup> [`<>`](http://github.com/charto/cwait/blob/c57c0fd/src/TaskQueue.ts#L7-L11)  \n> > &emsp;&#x25aa; Promise <sup><code>[PromisyClass](#api-PromisyClass)&lt;PromiseType&gt;</code></sup>  \n> > &emsp;&#x25aa; concurrency <sup><code>number</code></sup>  \n> > **.add( )** <sup>&rArr; <code>PromiseType</code></sup> [`<>`](http://github.com/charto/cwait/blob/c57c0fd/src/TaskQueue.ts#L16-L33)  \n> > &emsp;<em>Add a new task to the queue.</em>  \n> > &emsp;<em>It will start when the number of other concurrent tasks is low enough.</em>  \n> > &emsp;&#x25aa; func <sup><code>() =&gt; PromiseType</code></sup>  \n> > **.unblock( )** <sup>&rArr; <code>PromiseType</code></sup> [`<>`](http://github.com/charto/cwait/blob/c57c0fd/src/TaskQueue.ts#L38-L46)  \n> > &emsp;<em>Consider current function idle until promise resolves.</em>  \n> > &emsp;<em>Useful for making recursive calls.</em>  \n> > &emsp;&#x25aa; promise <sup><code>PromiseType</code></sup>  \n> > **.wrap( )** <sup>&rArr; <code>(...args: any[]) =&gt; PromiseType</code></sup> [`<>`](http://github.com/charto/cwait/blob/c57c0fd/src/TaskQueue.ts#L51-L53)  \n> > &emsp;<em>Wrap a function returning a promise, so that before running</em>  \n> > &emsp;<em>it waits until concurrent invocations are below this queue's limit.</em>  \n> > &emsp;&#x25aa; func <sup><code>(...args: any[]) =&gt; PromiseType</code></sup>  \n> > &emsp;&#x25ab; thisObject<sub>?</sub> <sup><code>any</code></sup>  \n>  \n> Properties:  \n> > **.concurrency** <sup><code>number</code></sup>  \n> > &emsp;<em>Number of promises allowed to resolve concurrently.</em>  \n\nLicense\n=======\n\n[The MIT License](https://raw.githubusercontent.com/charto/cwait/master/LICENSE)\n\nCopyright (c) 2015-2016 BusFaster Ltd\n","readmeFilename":"README.md","_id":"cwait@1.0.1","_shasum":"db258686e4632a5333bc230ccb4f738b2c41467b","_resolved":"https://registry.npmjs.org/cwait/-/cwait-1.0.1.tgz","_from":"https://registry.npmjs.org/cwait/-/cwait-1.0.1.tgz"}